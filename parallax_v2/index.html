
<!DOCTYPE html>

<html lang="ru">

	<head>

		<title>Parallax-v2</title>

		<link rel="stylesheet" href="css/style.css" />

		<meta charset="UTF-8">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
	</head>

	<body>

		<div class="wrapper">
			<section class="parallax">
				<div class="parallax_body">
					<div class="parallax_container _container">
						<div class="parallax_label">Hi!</div>
						<h1 class="parallax_title">This is <br> version 2</h1>
					</div>
					<div class="parallax_images images-parallax">
						<div class="images-parallax_item">
							<div class="images-parallax_clouds"></div>
						</div>
						<div class="images-parallax_item">
							<div class="images-parallax_mountains"></div>
						</div>
						<div class="images-parallax_item">
							<div class="images-parallax_human"></div>
						</div>
					</div>

				</div>
			</section>
			<section class="content">
				<div class="content_container _container">
					<h2 class="content_title">Next content</h2>
					<div class="content_text">Как работает виртуальный DOM
						Теперь, когда мы увидели, как выглядит виртуальный DOM, как он работает для решения проблем производительности и удобства использования DOM?

						Как я уже упоминал, мы можем использовать виртуальный DOM, чтобы выделить конкретные изменения, которые необходимо внести в DOM, и сделать эти конкретные обновления по отдельности. Давайте вернемся к нашему неупорядоченному списку и внесем те же изменения, что и в DOM API.

						Первое, что мы сделаем, это сделаем копию виртуального DOM, содержащего изменения, которые мы хотим сделать. Поскольку нам не нужно использовать API DOM, мы фактически можем просто создать новый объект полностью.</div>
				</div>

			</section>

		</div>
		<script src="js/script.js"></script>

	</body>
</html>